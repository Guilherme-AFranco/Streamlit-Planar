from packs import *
from auxiliary_functions import *
from calibration_functions import *

st.set_page_config(
    page_title='DASHBOARD - Sensor Planar',
    page_icon='üí≤',
    layout='wide',
    initial_sidebar_state='expanded',
    menu_items={
        'Get Help': 'https://br.linkedin.com/in/guilherme-aparecido',
        'Report a bug': "https://br.linkedin.com/in/guilherme-aparecido",
        'About': "App desenvolvido para inspe√ß√£o do sensor planar."
    }
)

engine = SQLEngine()

sql = 'SHOW TABLES'
statusMessage = st.empty()
while True:
    try:
        df = pd.read_sql(sql, con=engine)
        break
    except Exception as e:
        statusMessage.write(f"O aplicativo Docker ainda est√° processando. Tentando novamente em 5 segundos... {e}")
        time.sleep(4)
        statusMessage.empty()
        time.sleep(1)
with st.sidebar:
    logo = Image.open('./Imagens/Lemi-Logo.png')
    st.image(logo, width=300)
    st.subheader('Navega√ß√£o - Planar')
    st.markdown("---")
    page = st.radio(
        "Selecione a fun√ß√£o desejada:", 
        (
            "üìÇ Inclus√£o/Exclus√£o de arquivos", 
            "‚öôÔ∏è Gerador de matriz de calibra√ß√£o", 
            "üîç An√°lise dos dados adquiridos", 
            "üìà An√°lise em fun√ß√£o do polin√¥mio"
        )
    )
    st.sidebar.markdown("---")
    if st.sidebar.button('Exit'):
        st.write("Aplicativo est√° sendo fechado...")
        closeStream()

# P√ÅGINA 1
if page == "üìÇ Inclus√£o/Exclus√£o de arquivos":
    cols = st.columns(3)
    with cols[0]:
        analysisType = st.radio("Inclus√£o de arquivos para:", ("An√°lise", "Calibra√ß√£o"),horizontal=True)
        if analysisType == "Calibra√ß√£o":
            Rx = st.number_input("Digite o n√∫mero de canais Rx usado no sensor planar:", step=1, value=0)
        folderPath = st.text_input("Digite o caminho para inserir os arquivos (ex.: E:\\Planar\\Calib):")
        if st.button('Incluir arquivos') and folderPath:
            try:
                statusMessage = st.empty()
                statusMessage.write("Realizando inclus√£o dos arquivos selecionados...")
                if analysisType=="Calibra√ß√£o":
                    insertFiles(folderPath, Rx)
                else:
                    insertFiles(folderPath)
                statusMessage.empty()
                st.write("Arquivos carregados corretamente.")
            except:
                st.write("Ocorreu um erro na importa√ß√£o. Verifique se os dados est√£o no formato correto.")
    with cols[1]:
        df['Arquivos alocados'] = df['Tables_in_base_de_dados']
        deletFile = st.multiselect('Selecione os arquivos para exclus√£o (essa exclus√£o √© irrevers√≠vel).', df['Arquivos alocados'])        
        if st.button('Excluir arquivos') and deletFile:
            statusMessage = st.empty()
            statusMessage.write("Realizando exclus√£o do(s) arquivo(s) selecionado(s)...")
            for arquivo in deletFile:
                excludeFiles(arquivo)
            statusMessage.empty()
            st.write("Exclus√£o conclu√≠da")
        else:
            st.write("Nenhum arquivo selecionado.")
    with cols[2]:
        st.write(df['Arquivos alocados'])
    st.write('''
    Obs. 1: Os nomes dos arquivos de calibra√ß√£o a incluir devem ser no formato \'XXXu-YY\'. \n
    Onde XXX √© a espessura do cilindro de calibra√ß√£o (400, 520, ...) e YY √© a coleta realizada (00, 01, 02, 03, ...). \n
    Obs. 2: Para inclus√£o de arquivos de calibra√ß√£o, √© necess√°rio a inclus√£o da quantidade de arquivos referente √† quantidade de canais de recep√ß√£o (Rx) do projeto. \n
    Isso se deve √† necessidade de obter uma curva de calibra√ß√£o para cada canal (ou seja, cada arquivo refere-se ao teste onde o cilindro est√° posicionado na faixa de recep√ß√£o.
    ''')

# P√ÅGINA 2
elif page == "‚öôÔ∏è Gerador de matriz de calibra√ß√£o":
    col1 = st.columns(3)
    with col1[0]:
        thicknessFilter = df[df['Tables_in_base_de_dados'].str.contains(r'^\d')]['Tables_in_base_de_dados']
        thicknessSelect = st.multiselect('Selecione a(s) espessura(s) de cilindros usados para calibra√ß√£o.', thicknessFilter.apply(lambda x: valueExtract(x)).unique().tolist())
    filteredThickness = {}
    try:
        for value in thicknessSelect:
            filteredThickness[value] = df[df['Tables_in_base_de_dados'].apply(lambda x: x.startswith(value))]['Tables_in_base_de_dados'].tolist()
    except:
        st.write("Verifique se h√° arquivos para an√°lise.")
    with col1[1]:
        vhFilter = df[df['Tables_in_base_de_dados'].str.startswith('VH')]['Tables_in_base_de_dados']
        selectedVh = st.selectbox('Selecione o VH coletado.', vhFilter)
        tx = st.number_input("Digite o valor de Tx usado no sensor planar:", step=1, value=0)
    if 'calPixel' not in st.session_state:
        st.session_state.calPixel = st.session_state.matrix1Fig = None
    if st.button('Gerar Matriz'):
        if thicknessSelect and selectedVh and tx!=0:
            statusMessage = st.empty()
            statusMessage.write("Gerando matriz de calibra√ß√£o...")
            try:
                st.session_state.calPixel, thickValue, voltage = calibGenerator(filteredThickness, selectedVh, tx, extraAnalisys='Poly')
                statusMessage.empty()
                st.write("Curvas de calibra√ß√£o geradas")
            except:
                st.write("Erro na gera√ß√£o de calibra√ß√£o, verifique se os dados est√£o corretos.")
            st.session_state.matrix1Fig = plotCalib(thickValue, voltage)
        else:
            st.write("Coeficientes inv√°lidos / n√£o selecionados.")
    if st.session_state.matrix1Fig:
        col2 = st.columns(2)
        with col2[0]:
            st.plotly_chart(st.session_state.matrix1Fig, use_container_width=True)
        with col2[1]:
            with st.form(key='save_form'):
                calName = st.text_input("Nome do arquivo de calibra√ß√£o (ex.: Matriz_calibXX)")
                submit = st.form_submit_button(label='Salvar equa√ß√£o no banco de dados')
                if submit and calName:
                    statusMessage = st.empty()
                    statusMessage.write("Incluindo matriz no banco de dados...")
                    try:
                        insertMatrix(st.session_state.calPixel, calName)
                        statusMessage.empty()
                        st.write("Matriz incluida.")
                    except:
                        st.write("Nome incluso incorretamente.")
    else:
        st.write("Gere as curvas antes.")
    col3 = st.columns(3)
    with col3[0]:
        matrixNames = df[df['Tables_in_base_de_dados'].str.startswith('Matriz')]['Tables_in_base_de_dados'].reset_index(drop=True)
        matrixThickness = st.selectbox('Selecione a matriz de calibra√ß√£o', matrixNames.apply(lambda x: valueExtract(x,"matrix")).unique().tolist())

    if 'curves' not in st.session_state:
        st.session_state.curves = False
    if "rxSelected" not in st.session_state and "rxValues" not in st.session_state:
        st.session_state.rxValues = st.session_state.rxSelected = None
    if st.button("Analise"):
        calFiltered = df[df['Tables_in_base_de_dados'].str.startswith(matrixThickness)]['Tables_in_base_de_dados'].tolist()
        try:
            matrixCal, st.session_state.rxValues = importCal(calFiltered)
            st.session_state.matrixCal = matrixCal
        except:
            st.write("Erro na an√°lise da matriz.")
        st.session_state.curves = True
    if st.session_state.curves:
        if st.session_state.rxSelected:
            planar = Image.open(f'./Imagens/Rx{st.session_state.rxSelected:02d}.png')
        else:
            planar = Image.open(f'./Imagens/Sensor_Planar.jpg')
        col4 = st.columns(2)
        with col4[0]:
            st.write('Faixa de sele√ß√£o da curva de calibra√ß√£o')
            st.markdown("<br>", unsafe_allow_html=True)
            st.image(planar)
            col5 = st.columns(4)
            with col5[0]:
                rx_option = st.selectbox("Selecione um canal Rx:", st.session_state.rxValues)
                rxSelected = st.session_state.rxValues.index(rx_option)
            with col5[1]:
                st.markdown("<br>", unsafe_allow_html=True)
                if st.button(f"Gerar curva"):
                    st.session_state.rxSelected = rxSelected+1
                    st.experimental_rerun()
            with col5[2]:
                if st.button(f"Mostrar todas as curvas"):
                    st.session_state.rxSelected = None
                    st.experimental_rerun()
        with col4[1]:
            thickValue, voltage = calCurve2(st.session_state.matrixCal)
            if st.session_state.rxSelected:
                matrix2Fig = plotCalib(thickValue, voltage[:,st.session_state.rxSelected-1,:],st.session_state.rxSelected)
            else:
                matrix2Fig = plotCalib(thickValue, voltage)
            st.session_state.matrix2Fig = matrix2Fig
            st.plotly_chart(st.session_state.matrix2Fig, use_container_width=True)
            if 'matrixCal' in st.session_state and st.session_state.rxSelected:
                st.write('Equa√ß√£o da curva:')
                matrixFilteredNames = [value for value in matrixNames if value.startswith(matrixThickness)]
                rxName = [f'Rx{st.session_state.rxSelected:02d}']
                st.write(f'f(x) = {st.session_state.matrixCal[matrixFilteredNames[4]][rxName].mean().values[0]:.2e}.x^4+{st.session_state.matrixCal[matrixFilteredNames[3]][rxName].mean().values[0]:.2e}.x^3+{st.session_state.matrixCal[matrixFilteredNames[2]][rxName].mean().values[0]:.2e}.x^2+{st.session_state.matrixCal[matrixFilteredNames[1]][rxName].mean().values[0]:.2e}.x+{st.session_state.matrixCal[matrixFilteredNames[0]][rxName].mean().values[0]:.2e}')
                st.write('Onde:')
                st.write('x: espessura de filme; f(x): tens√£o.')

# P√ÅGINA 3
elif page == "üîç An√°lise dos dados adquiridos":
    st.write("A an√°lise dessa se√ß√£o ser√° realizada sem a presen√ßa do ajuste pelo polin√¥mio de calibra√ß√£o.")
    cols = st.columns(4)
    names = df[df['Tables_in_base_de_dados'].str.contains(r'^\d')]['Tables_in_base_de_dados']
    with cols[0]:
        filteredThickness = {}
        thicknessSelect = [st.selectbox('Selecione a coleta de an√°lise', names.apply(lambda x: valueExtract(x)).unique().tolist())]
        try:
            for value in thicknessSelect:
                filteredThickness[value] = df[df['Tables_in_base_de_dados'].apply(lambda x: x.startswith(value))]['Tables_in_base_de_dados'].tolist()
        except:
            st.write("Verifique se h√° arquivos para an√°lise")
    vhNames = df[df['Tables_in_base_de_dados'].str.startswith('VH')]['Tables_in_base_de_dados']
    with cols[1]:
        selectedVh = st.selectbox('Selecione o VH', vhNames)
    with cols[2]:
        tx = st.number_input("Digite o valor de Tx usado no sensor planar:", step=1, value=0)
    with cols[3]:
        rx = st.number_input("Digite o n√∫mero de canais Rx usado no sensor planar:", step=1, value=0)
    if st.button('Gerar gr√°ficos'):
        if thicknessSelect and selectedVh and tx!=0 and rx!=0:
            statusMessage = st.empty()
            statusMessage.write("Gerando gr√°ficos...")
            try:
                minRx, meanRc, thick = calibGenerator(filteredThickness, selectedVh, tx)
            except:
                st.write("Erro na an√°lise, verifique se a espessura, VH e valor de tx est√£o coerentes.")
            statusMessage.empty()
            for _ in range(len(minRx.keys())):
                fig = basicPlot(thick[next(iter(thick))],minRx[next(iter(minRx))],meanRc[next(iter(meanRc))],rx,tx,type='min')
                st.plotly_chart(fig)
        else:
            st.write("Erro: Arquivos n√£o selecionados.")

# P√ÅGINA 4
elif page == "üìà An√°lise em fun√ß√£o do polin√¥mio":
    names = df['Tables_in_base_de_dados']
    vhNames = df[df['Tables_in_base_de_dados'].str.startswith('VH')]['Tables_in_base_de_dados']
    matrixNames = df[df['Tables_in_base_de_dados'].str.startswith('Matriz')]['Tables_in_base_de_dados']
    cols = st.columns(3)
    filteredAnalysis = {}
    with cols[0]:
        generalName = st.selectbox('Selecione o nome geral da an√°lise', names.apply(lambda x: valueExtract(x,"regex")).unique().tolist())
        filteredName = names[names.str.startswith(generalName)]
        filteredAnalysis[generalName] = st.multiselect(f'Selecione o(s) arquivo(s) da s√©rie "{generalName}"', filteredName.tolist())
    with cols[1]:
        matrixSelected = st.selectbox('Selecione a matriz de calibra√ß√£o', matrixNames.apply(lambda x: valueExtract(x,'matrix')).unique().tolist())
        vhFiltered = st.selectbox('Selecione o VH', vhNames)
    with cols[2]:
        tx = st.number_input("Digite o valor de Tx usado no sensor planar:", step=1, value=0)
    try:
        matrixFiltered = df[df['Tables_in_base_de_dados'].str.startswith(matrixSelected)]['Tables_in_base_de_dados'].tolist() # Obtendo todos os arquivos da espessura selecionada
    except:
        st.write("Verifique se h√° arquivos para an√°lise")
    if 'analysis' not in st.session_state:
        st.session_state.analysis = st.session_state.fitAnalysis = st.session_state.meanRc = st.session_state.rx = None
    if st.button('Gerar an√°lise'):
        if filteredAnalysis and vhFiltered and matrixFiltered:
            st.write("Gerando an√°lise...")
            try:
                st.session_state.analysis,st.session_state.fitAnalysis, st.session_state.meanRc, st.session_state.rx = analysisGenerator(filteredAnalysis,vhFiltered,matrixFiltered,tx)
            except Exception as e:
                st.write("Erro na an√°lise, verifique se as vari√°veis inclusas acima est√£o corretas.",e)
            st.write("An√°lise gerada")
        else:
            st.write("Selecione todas as caixas de sele√ß√£o.")
    if st.session_state.analysis is not None and st.button("Gerar gr√°ficos"):
        if st.session_state.analysis and not st.session_state.fitAnalysis.empty and not st.session_state.meanRc.empty and st.session_state.rx:
            try:
                for value in st.session_state.meanRc:
                    fig = basicPlot(st.session_state.analysis[next(iter(st.session_state.analysis))][value],st.session_state.fitAnalysis[value],st.session_state.meanRc[value],st.session_state.rx,tx,type='fit')
                    st.plotly_chart(fig)
            except:
                st.write("Erro na plotagem, verifique se a an√°lise √© coerente.")